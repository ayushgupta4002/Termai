from pydantic import BaseModel, Field
import typer
import subprocess
import shlex
import os
import platform
from typing import Optional, List
import google.generativeai as genai
from langchain_google_genai import ChatGoogleGenerativeAI

from utils import detect_shell, validate_command

app = typer.Typer()

# Initialize Gemini model
os.environ["GOOGLE_API_KEY"] = ""
llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash")

class QueryChecker(BaseModel):
    commands: List[str] = Field(
        description="The list of shell commands generated by the LLM"
    )

def get_shell_command(instruction: str) -> str:
    """Use Gemini to generate a shell command from natural language instruction."""
    system_info = "windows" if platform.system().lower() == "windows" else "unix"
    shell_type = detect_shell()
    typer.echo(f"Detected shell: {shell_type}")
    prompt = f"""
    You are an AI assistant that converts natural language instructions into **safe and precise shell commands** for {system_info} systems.
    The user is currently using {shell_type} shell.
    - Use only commands valid for {shell_type} shell

    ### **Guidelines:**
    1. **Safety First:**  
    - Only generate **non-destructive** commands.  
    - Avoid commands that delete files, modify system settings, or execute unknown scripts.  
    2. **System-Specific Commands:**  
    - On **Windows**, prefer `dir` over `ls`, and `cd` for navigation.  
    - On **Unix/Linux**, prefer `ls` over `dir`.  
    3. **Structured Output:**  
    - If a single command is enough, return a **single command**.  
    - If multiple steps are required, return a **list of commands**, in the correct execution order.  
    4. **No Dangerous Commands:**  
    - **Forbidden commands:** `rm -rf`, `del /s`, `mv *`, `sudo`, `curl | sh`, `format`, `shutdown`, etc.  
    5. **Minimal Output:**  
    - **Return only the shell command(s)** without explanations or additional text.  
    - Use only commands valid for {shell_type} shell
    Examples for different shells:
    - PowerShell: Get-ChildItem, Get-Content, Set-Location
    - CMD: dir, type, cd
    - Bash: ls, cat, cd


    ### **Instruction:**  
    Convert the following instruction into a {shell_type} command or a list of {shell_type} commands:  

    **Instruction:** "{instruction}"

    ### **Expected Output:**  
    A **single valid shell command** or an **array of shell commands** for a {system_info} system.
    """

    response = llm.with_structured_output(QueryChecker).invoke(prompt)
    # response = llm.invoke(prompt)
    print(response)
    typer.echo(f"response was generated: {response.commands}")
    
    return response.commands

def execute_command(commands: List[str]) -> None:
    """Execute command(s), handling compound commands and special cases."""
    # Split compound commands
    # commands = split_commands(command)
    shell = detect_shell()
    for cmd in commands:
        cmd = cmd.strip()
        typer.echo(f"\nExecuting: {cmd}")
        if not validate_command(cmd):
            typer.echo("Error: Generated command failed safety validation", err=True)
            raise typer.Exit(1)

        if cmd.lower().startswith('cd '):
            # Handle cd command
            path = cmd[3:].strip()
            try:
                os.chdir(path)
                typer.echo(f"Changed directory to: {os.getcwd()}")
            except Exception as e:
                typer.echo(f"Error changing directory: {str(e)}", err=True)
                raise typer.Exit(1)
        else:
            # Handle other commands
            try:
                if platform.system().lower() == "windows":
                    if (shell == "powershell"):
                        result = subprocess.run(
                            ['powershell', '-Command', cmd],
                            text=True,
                            capture_output=True,
                            check=True
                        )
                    else:

                        result = subprocess.run(
                            ['cmd', '/c', cmd],
                            text=True,
                            capture_output=True,
                            check=True
                        )
                else:
                    result = subprocess.run(
                        cmd,
                        shell=True,
                        text=True,
                        capture_output=True,
                        check=True
                    )
                if result.stdout:
                    typer.echo(result.stdout)
            except subprocess.CalledProcessError as e:
                typer.echo(f"Error executing command: {e.stderr}", err=True)
                raise typer.Exit(1)

@app.command()
def run(
    instruction: str = typer.Argument(..., help="Natural language instruction to convert to shell command"),
    execute: bool = typer.Option(False, "--execute", "-e", help="Actually execute the command"),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Show detailed output")
):
    """Convert natural language instructions into shell commands and optionally execute them."""
    if verbose:
        typer.echo(f"Processing instruction: {instruction}")
    
    try:
        command = get_shell_command(instruction)
        
        if not command:
            typer.echo("Error: No command was generated", err=True)
            raise typer.Exit(1)
        
        typer.echo(f"\nGenerated command: {command}")
        
        if execute:
            typer.echo("\nExecuting command...")
            execute_command(command)
        else:
            typer.echo("\nUse --execute or -e flag to run the command")
            
    except Exception as e:
        typer.echo(f"Error: {str(e)}", err=True)
        raise typer.Exit(1)

if __name__ == "__main__":
    app()