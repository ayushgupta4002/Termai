from pydantic import BaseModel, Field
import typer
import subprocess
import shlex
import os
import platform
from typing import Optional, List
import google.generativeai as genai
from langchain_google_genai import ChatGoogleGenerativeAI
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.style import Style
console = Console()
from utils import detect_shell, validate_command

app = typer.Typer()

# Initialize Gemini model
os.environ["GOOGLE_API_KEY"] = ""
llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash")

class QueryChecker(BaseModel):
    commands: List[str] = Field(
        description="The list of shell commands generated by the LLM"
    )
class FinalOutput (BaseModel):
    commands: str= Field(
        description="The final output generated by the LLM"
    )

def get_shell_command(instruction: str) -> str:
    """Use Gemini to generate a shell command from natural language instruction."""
    system_info = "windows" if platform.system().lower() == "windows" else "unix"
    shell_type = detect_shell()
    typer.echo(f"Detected shell: {shell_type}")
    prompt = f"""
    You are an AI assistant that converts natural language instructions into **safe and precise shell commands** for {system_info} systems.
    The user is currently using {shell_type} shell.

    ### **Guidelines:**
    1. **Safety First:**  
    - Only generate **non-destructive** commands.  
    - Avoid commands that delete files, modify system settings, or execute unknown scripts.  

    2. **System-Specific Commands:**  
    - On **Windows**, prefer `dir` over `ls`, and `cd` for navigation.  
    - On **Unix/Linux**, prefer `ls` over `dir`.  

    3. **Structured Output:**  
    - If a single command is enough, return a **single command**.  
    - DO NOT RETURN EMPTY ARRAY, NEVER  
    - If multiple steps are required, return a **list of commands**, in the correct execution order.  

    4. **No Dangerous Commands:**  
    - **Forbidden commands:** `rm -rf`, `del /s`, `mv *`, `sudo`, `curl | sh`, `format`, `shutdown`, etc.  

    5. **Minimal Output:**  
    - **Return only the shell command(s)** without explanations or additional text.  
    - Use only commands valid for {shell_type} shell.  

    6. **Mandatory Use of Non-Interactive Flags (`--yes`, `--force`, `-y`, etc.)**  
    - Always use `--yes`, `--force`, `-y`, or equivalent to prevent user interaction.  
    - Ensure every command that may require confirmation (like `npm create next-app`, `npx shadcn-ui init`) includes `--yes`, `--force`, `-y`, or equivalent.  
    - **For `npx create-next-app`, always include `--use-npm` (or `--use-yarn` / `--use-pnpm` based on context) along with `--yes` to prevent package manager selection prompts.**  
    7. **PowerShell Here-String Handling (If Applicable)**  
    - If generating a PowerShell script that writes multiline text (e.g., `main.go` file creation), ensure:  
        - Use `@'` and `'@` syntax correctly (each on its own line).  
        - Do **not** place extra characters before or after the here-string declaration.  
        - Ensure correct file encoding (`utf8`).  
    - Apply this approach to any `npx` commands that prompt for package installation.  

    ### **Instruction:**  
    Convert the following instruction into a {shell_type} command or a list of {shell_type} commands:  

    **Instruction:** "{instruction}"

    ### **Expected Output:**  
    A **single valid shell command** or an **array of shell commands** for a {system_info} system.  
    DO NOT RETURN EMPTY ARRAY, NEVER  

        
    """
    # console.print(Panel(Text(prompt, style="bold cyan"), title="Instruction to Command", expand=False))
    response = llm.with_structured_output(QueryChecker).invoke(prompt)
    # response = llm.invoke(prompt)
    # print(" Response : ", response)
   
    formatted_text = "\n".join([f"[bold green]{idx}. {cmd}[/]" for idx, cmd in enumerate(response.commands, start=1)])

    # Simulate a blur effect by using a dim/transparent-like background
    blur_style = Style(bgcolor="grey15", dim=True)  # Darker + dimmed effect

    console.print(Panel(Text.from_markup(formatted_text), title="Generated Commands", expand=False, style=blur_style))
    return response.commands


def execute_command(commands: List[str], query: str) -> None:
    """Execute command(s), handling compound commands and special cases."""

    shell = detect_shell()
    output = []
    executed_commands = []

    for cmd in commands:
        cmd = cmd.strip()
        executed_commands.append(cmd)

        typer.echo(typer.style("\nExecuting", fg=typer.colors.BRIGHT_YELLOW) + f": {cmd}")
        if not validate_command(cmd):
            typer.echo("Error: Generated command failed safety validation", err=True)
            raise typer.Exit(1)

        if cmd.lower().startswith('cd '):
            # Handle cd command
            path = cmd[3:].strip()
            try:
                os.chdir(path)
                typer.echo(f"Changed directory to: {os.getcwd()}")
            except Exception as e:
                typer.echo(f"Error changing directory: {str(e)}", err=True)
                raise typer.Exit(1)
        else:
            # Handle other commands
            try:
                if platform.system().lower() == "windows":
                    if shell == "powershell":
                        result = subprocess.run(
                            ['powershell', '-Command', cmd],
                            text=True,
                            check=True
                        )
                    else:
                        result = subprocess.run(
                            ['cmd', '/c', cmd],
                            text=True,
                            check=True
                        )
                else:
                    result = subprocess.run(
                        cmd,
                        shell=True,
                        text=True,
                        check=True
                    )
                
                if result.stdout:
                    output.append(result.stdout)
          
            except subprocess.CalledProcessError as e:
                error_msg = e.stderr.strip() if e.stderr else str(e)
                typer.secho(f"\n[!] Error executing command: {error_msg}", fg=typer.colors.RED, err=True)
                
                # Generate AI explanation
                prompt = f"""
                You are an AI assistant that explains shell command errors in **simple terms** for a user.
                - Error Message: "{error_msg}"
                - Explain the error clearly and provide potential fixes.
                - Format the response in a short and concise way.
                """
                response = llm.invoke(prompt)

                # Display error explanation in a styled box
                console.print(Panel(Text(response, style="bold yellow"), title="Error Explanation", expand=False))

                raise typer.Exit(1)
    
    # Formatting executed commands and outputs
    output_text = "\n".join(output) if output else "No output generated."

    # Display executed commands in a **box**
    
    # Display output in a **box**
    console.print(Panel(Text(output_text, style="bold green"), title="Command Output", expand=False))




@app.command()
def run(
    instruction: str = typer.Argument(..., help="Natural language instruction to convert to shell command"),
    execute: bool = typer.Option(False, "--execute", "-e", help="Actually execute the command"),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Show detailed output")
):
    """Convert natural language instructions into shell commands and optionally execute them."""
    if verbose:
        typer.echo(f"Processing instruction: {instruction}")
    
    try:
        command = get_shell_command(instruction)
        
        if not command:
            typer.echo("Error: No command was generated", err=True)
            raise typer.Exit(1)
        
        # typer.echo(f"\nGenerated command: {command}")
        
        if execute:
            typer.echo("\nExecuting commands...")
            execute_command(command , instruction)
        else:
            typer.echo("\nUse --execute or -e flag to run the command")
            
    except Exception as e:
        typer.echo(f"Error: {str(e)}", err=True)
        raise typer.Exit(1)

if __name__ == "__main__":
    app()